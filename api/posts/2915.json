{"title":"算法之基础","slug":"算法之基础","date":"2020-04-18","updated":"2020-04-19","comments":true,"path":"api/posts/2915.json","excerpt":"<p> 算法基础，了解算法的基础知识，算法的种类，知道什么是好算法。</p>","cover":null,"covers":null,"content":"<p>算法基础，了解算法的基础知识，算法的种类，知道什么是好算法。</p><a id=\"more\"></a><h1 id=\"算法特性\"><a class=\"headerlink\" href=\"# 算法特性\"></a>算法特性 </h1><ul><li><strong> 输入 </strong>：可以有零个或多个参数</li><li><strong> 输出 </strong>：必须有一个或多个结果</li><li><strong> 有穷性 </strong>：算法必须会结束，没有无限循环</li><li><strong> 确定性 </strong>：有唯一结果</li><li><strong> 可行性 </strong>：算法每一步都能通过执行有限次数完成</li></ul><h1 id=\"算法设计要求\"><a class=\"headerlink\" href=\"# 算法设计要求\"></a> 算法设计要求 </h1><ul><li><strong> 正确性 </strong>：算法至少具有输入、输出和过程明确的加工处理，正确反映问题的需求，最后得到期望的答案<ul><li> 算法程序没有语法错误 </li><li> 算法程序对于合法输入能产生期望的答案 </li><li> 算法程序对于非法输入能产生警告和提示 </li><li> 算法程序对于故意掉难得测试输入都能产生期望的结果 </li></ul></li><li><strong> 可读性 </strong>：算法便于阅读、理解和交流</li><li><strong> 健壮性 </strong>：能够处理异常、崩溃或莫名其妙的结果</li><li><strong> 高时间效率和低存储量 </strong>：算法要考虑处理速度和内存用量</li></ul><h1 id=\"算法效率度量方法\"><a class=\"headerlink\" href=\"# 算法效率度量方法\"></a> 算法效率度量方法 </h1><ul><li> 事后统计方法：通过执行多个输入测试，记录执行时间平均值 </li><li> 事前估算方法：通过统计方法对算法进行估算，涉及以下因素 <ol><li> 算法策略，<strong>例子使用公式或者循环等 </strong></li><li> 编译后的代码质量，<strong>基础操作的次数统计 </strong></li><li> 问题的输入规模，<strong>例子数值大小或元素数量等 </strong></li><li> 机器执行指令的速度，<strong>硬件性能 </strong></li></ol></li></ul><p><strong> 算法基础种类分别有：<code>1</code>、<code>n</code>、<code>n*n</code>。</strong></p><p>一般使用公式或瀑布式条件判断的算法策略属于 <code>1</code>；使用单个循环的属于<code>n</code>；使用嵌套循环的属于<code>n*n</code>。3 种算法中往往常数算法<code>1</code> 要优于 <code>n</code> 和<code>n*n</code>。给以下基础操作次数公式分类：</p><ul><li><code>1</code>：<code>3</code>、<code>5</code>、<code>9</code>等 </li><li><code>n</code>：<code>n</code>、<code>n+1</code>、<code>2n+3</code> 等</li><li><code>n*n</code>：<code>n^2</code>、<code>n^2+5</code>、<code>2n^3+1</code>等 </li></ul><p><strong> 一般判断算法好坏，更应该关注函数公式的主项：指数最高项。</strong><br>比如算法 <code>2n^2+n+3</code> 对比算法 <code>n^3+2n+1</code>，因为<code>2n^2</code> 指数低于 <code>n^3</code>，所以算法<code>2n^2+n+3</code> 优于算法 <code>n^3+2n+1</code>。</p><h2 id=\"怎么分析一个算法的输入时间？\"><a class=\"headerlink\" href=\"# 怎么分析一个算法的输入时间？\"></a> 怎么分析一个算法的输入时间？</h2><ul><li>抽象算法：去除算法中循环的外包装、条件的判断、变量的声明、打印输出等操作 </li><li> 指令计数：统计关联的输入模式下基础操作的数量 </li></ul><h2 id=\"求和 1-100 的算法例子分析\"><a class=\"headerlink\" href=\"# 求和 1-100 的算法例子分析\"></a> 求和 1-100 的算法例子分析 </h2><p> 以下 <em> 算法一 </em>，算法策略使用<code> 循环 </code>，编译后的代码质量为<code>n</code> 次，问题的输入规模 <code>100</code>，机器执行指令的速度取决于算法运行所在计算机。</p><figure class=\"highlight js\"><figcaption><span>JavaScript 算法一</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>, i = <span class=\"number\">1</span>, n = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (; i &lt;= n; i++) &#123;</span><br><span class=\"line\">  sum += i;                  <span class=\"comment\">// 执行 n 次</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 以下 <em> 算法二 </em>，算法策略使用<code> 公式 </code>，编译后的代码质量为<code>1</code> 次，问题的输入规模 <code>100</code>，机器执行指令的速度取决于算法运行所在计算机。</p><figure class=\"highlight js\"><figcaption><span>JavaScript 算法二</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>, i = <span class=\"number\">1</span>, n = <span class=\"number\">100</span>;</span><br><span class=\"line\">sum = (i + n) * n  / <span class=\"number\">2</span>;      <span class=\"comment\">// 执行 1 次</span></span><br></pre></td></tr></table></figure><p> 对比以上算法，它们的输入规模都是 <code>100</code>，在同一计算机运行的情况下，<strong> 算法一 </strong> 的基础操作次数受输入规模的影响，造成工作量超出 <strong> 算法二 </strong>，<strong> 所以算法二效率更高 </strong>。</p><h2 id=\"求和 3x3 表格内数值的例子分析\"><a class=\"headerlink\" href=\"# 求和 3x3 表格内数值的例子分析\"></a> 求和 3x3 表格内数值的例子分析 </h2><p> 以下 <em> 表格遍历例子 </em>，算法策略使用<code> 嵌套的循环 </code>，编译后的代码质量为<code>n^2</code> 次，问题的输入规模 <code>3x3</code>，机器执行指令的速度取决于算法运行所在计算机。</p><figure class=\"highlight js\"><figcaption><span>JavaScript 表格遍历求和例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>, </span><br><span class=\"line\">    table = [</span><br><span class=\"line\">      [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">      [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">      [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">    ];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= table.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= table[i].length; j++) &#123;</span><br><span class=\"line\">    sum += table[i][j];      <span class=\"comment\">// 执行 n^2 次</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 以上算法，它根据表格的大小，基础操作的数量是以指数上升的，<strong>所以 <code>3x3</code> 的表格内数值总和计算一共有基础操作 <code>3^2</code> 等于 9 次 </strong>。</p><h1 id=\"用大 O 记法表示算法时间复杂度\"><a class=\"headerlink\" href=\"# 用大 O 记法表示算法时间复杂度\"></a> 用大 O 记法表示算法时间复杂度 </h1><p> 复杂度分为：<strong>时间复杂度 </strong> 或<strong>空间复杂度 </strong><br><strong> 一般计算“复杂度”是指“时间复杂度”，而不是空间复杂度，目前主流还是时间复杂度，不求用内存换取时间。</strong></p><p><strong>T(n) = O(f(n))</strong>，<code>f(n)</code>为算法的函数或入口，随着输入规模 <code>n</code> 的增长，<code>T(n)</code>增长最慢的算法为最优算法。因为以下原因：</p><p><strong>基础操作数量 = 时间 </strong></p><p> 所以当 <code>n</code> 翻倍时，<em>基础操作数量 </em> 增长越少，花费的 <em> 时间 </em> 越少。</p><p>上面用到的三个求和算法例子，如果用大 O 表示算法的时间复杂度分别为 <code>O(1)</code>、<code>O(n)</code>、<code>O(n^2)</code>。</p><p><strong> 大 O 记法表示时间的增长率 </strong></p><ul><li><code>O(1)</code>：增长率不变</li><li><code>O(n)</code>：增长率倍数增长</li><li><code>O(n^2)</code>：增长率指数增长</li></ul><h2 id=\"推导大 O 阶方法\"><a class=\"headerlink\" href=\"# 推导大 O 阶方法\"></a> 推导大 O 阶方法 </h2><p> 用一下方法来推导 <code>5</code>、<code>2n+3</code>、<code>n(n+1)/2</code> 和<code>O(logn)</code>的大 O 阶：</p><ol><li>用常数 1 取代所有加法常数 </li><li> 只保留最高阶项 </li><li> 最高阶项不是 1 的话，去除这个项相乘的常数 </li></ol><p><code>5</code> =&gt; <code>O(1)</code>，<br><code>2n+3</code> =&gt; <code>O(n)</code>，<br><code>n(n+1)/2</code> =&gt; <code>O(n^2)</code></p><p> 一面这个例子的话就是 <code>O(logn)</code>：</p><figure class=\"highlight js\"><figcaption><span>JavaScript</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, n = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; n) &#123;</span><br><span class=\"line\">  i *= <span class=\"number\">2</span>; <span class=\"comment\">// 2^x = n，那么 x = log(2)n，x 为循环次数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"常见的时间复杂度\"><a class=\"headerlink\" href=\"# 常见的时间复杂度\"></a> 常见的时间复杂度 </h2><table><thead><tr><th style=\"text-align:center\"> 例子 </th><th style=\"text-align:center\"> 时间复杂度 </th><th style=\"text-align:center\"> 术语 </th></tr></thead><tbody><tr><td style=\"text-align:center\">5</td><td style=\"text-align:center\">O(1)</td><td style=\"text-align:center\"> 常数阶 </td></tr><tr><td style=\"text-align:center\">3n+4</td><td style=\"text-align:center\">O(n)</td><td style=\"text-align:center\"> 线性阶 </td></tr><tr><td style=\"text-align:center\">3n^2+4n+5</td><td style=\"text-align:center\">O(n^2)</td><td style=\"text-align:center\"> 平方阶 </td></tr><tr><td style=\"text-align:center\">3log(2)n+4</td><td style=\"text-align:center\">O(logn)</td><td style=\"text-align:center\"> 对数阶 </td></tr><tr><td style=\"text-align:center\">2n+3nlog(2)n+14</td><td style=\"text-align:center\">O(nlogn)</td><td style=\"text-align:center\">nlogn 阶</td></tr><tr><td style=\"text-align:center\">n<sup>3+2n</sup>2+4n+6</td><td style=\"text-align:center\">O(n^3)</td><td style=\"text-align:center\"> 立方阶 </td></tr><tr><td style=\"text-align:center\">2^n</td><td style=\"text-align:center\">O(2^n)</td><td style=\"text-align:center\"> 指数阶 </td></tr></tbody></table><p> 时间复杂度对比：<br><strong><code>O(1)</code> &lt; <code>O(logn)</code> &lt; <code>O(n)</code> &lt; <code>O(nlogn)</code> &lt; <code>O(n^2)</code> &lt; <code>O(n^3)</code> &lt; <code>O(2^n)</code> &lt; <code>O(n!)</code> &lt; <code>O(n^n)</code></strong></p><blockquote><p>本文参考：<br><a href=\"https://www.bilibili.com/video/BV1jW411K7yg\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">【C 语言描述】《数据结构和算法》（小甲鱼）</a></p></blockquote>","url":"/posts/2915/","min2read":5,"word4post":"1.5k","prev_post":{"title":"数据结构之线性表 List","url":"/posts/6004/"},"next_post":{"title":"数据结构之基础","url":"/posts/46208/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"算法特性\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">算法特性 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"算法设计要求\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\"> 算法设计要求 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"算法效率度量方法\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\"> 算法效率度量方法 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"怎么分析一个算法的输入时间？\" href = \"#\"><span class=\"toc-number\">3.1.</span> <span class=\"toc-text\"> 怎么分析一个算法的输入时间？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"求和 1-100 的算法例子分析\" href = \"#\"><span class=\"toc-number\">3.2.</span> <span class=\"toc-text\"> 求和 1-100 的算法例子分析 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"求和 3x3 表格内数值的例子分析\" href = \"#\"><span class=\"toc-number\">3.3.</span> <span class=\"toc-text\"> 求和 3x3 表格内数值的例子分析 </span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"用大 O 记法表示算法时间复杂度\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\"> 用大 O 记法表示算法时间复杂度 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"推导大 O 阶方法\" href = \"#\"><span class=\"toc-number\">4.1.</span> <span class=\"toc-text\"> 推导大 O 阶方法 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"常见的时间复杂度\" href = \"#\"><span class=\"toc-number\">4.2.</span> <span class=\"toc-text\"> 常见的时间复杂度 </span></a></li></ol></li></ol>","categories":[{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json","url":"/categories/数据结构与算法/"}],"tags":[{"name":"基础","path":"api/tags/基础.json","url":"/tags/基础/"},{"name":"Big O","path":"api/tags/Big O.json","url":"/tags/Big-O/"}]}